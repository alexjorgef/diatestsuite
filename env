#!/usr/bin/env bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
    SCRIPT_FOLDER="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$SCRIPT_FOLDER/$SOURCE"
done
SCRIPT_FOLDER="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
unset SOURCE

function usage() {
    echo "Usage: env [OPTIONS] COMMAND [ARGS]..."
    echo
    echo "Options:"
    echo
    echo "  -h --help             Print help"
    echo
    echo "Commands:"
    echo
    echo "  start                 Start minikube"
    echo "  stop                  Stop minikube"
    echo "  delete                Delete minikube"
    echo "  build                 Build DIA images"
    echo "  install [full]        Install DIA platform"
    echo "  uninstall             Un-install DIA platform"
    echo "  create                Create a new resource"
    echo "  remove                Remove a resource"
    echo "  lint                  Lint code"
    echo "  clean                 Clean unused files"
    echo "  info                  Show detailed information"
    echo "  shell                 Connect to enviornment shell"
    echo "  logs                  Print logs"
    echo "  ping                  Make ping tests"
    echo
    echo "Report bugs to: <https://github.com/diadata-org/diadata/issues>"
}

function main() {
    local full=false

    local paths=()
    local args=
    args=$(
        getopt -o hnsg: \
            --long goto:,disk-space:,nodetached,full,help \
            -n 'env' -- "$@"
    )

    # shellcheck disable=SC2181
    if [ $? != 0 ]; then
        usage 1>&2
        return 1
    fi

    set -euo pipefail

    eval set -- "$args"

    while true; do
        case "$1" in
        --full | -f)
            full=true
            shift ;;
        --goto | -g)
            galias="$2"

            # shellcheck disable=SC1090
            source "$HOME/.oh-luis-bash/goto-command.sh"

            gpath="$(goto -x "$galias" 2>/dev/null)"
            if [ "$gpath" = "" ]; then
                echo "Invalid foto alias!" >&2
                return 1
            fi

            shift 2
            ;;
            --help | -h     ) usage; return 0 ;;
            --              ) shift; break    ;;
            *               )        break    ;;
        esac
    done

    # expand paths after parsing
    paths=("$@")

    if ! hash git 2> /dev/null; then echo "Git not found" >&2; return 1; fi
    if ! hash yq 2> /dev/null; then echo "yq not found" >&2; return 1; fi
    if ! hash docker 2> /dev/null; then echo "Docker not found" >&2; return 1; fi
    if ! hash minikube 2> /dev/null; then echo "Minikube not found" >&2; return 1; fi
    if ! hash golangci-lint 2> /dev/null; then echo "golangci-lint not found" >&2; return 1; fi

    # echo "${#paths[@]}"
    # echo "${paths[@]}"
    # echo "${paths:-.}"
    # echo "${paths[0]}"
    # echo "${paths[1]}"

    if [ -f "${paths:-.}" ] || [ "${#paths[@]}" -gt 1 ]; then
        edit_args=()
    fi

    if [[ "$OSTYPE" != "linux-gnu"* ]] && [[ "$OSTYPE" != "darwin"* ]]; then
        echo "Unknown operating system"
        exit 1
    fi

    MINIKUBE_PROFILE=dia
    MINIKUBE_K8S_VERSION=v1.25.7
    MINIKUBE_HW_DISK_SIZE=50g
    MINIKUBE_HW_CPUS=4
    MINIKUBE_HW_RAM=8g
    MINIKUBE_DRIVER=docker
    MINIKUBE_CERT_MOUNT=~/.minikube
    KUBECONFIG=~/.kube/config

    if [ -f "./.env.local" ]; then source ./.env.local; fi

    if [ ! -n "${paths[0]:-}" ]; then
        echo "No command specified" >&2
        exit 1
    fi
    case "${paths[0]}" in
    test-docker-images)
        if [[ "$(minikube -p "${MINIKUBE_PROFILE}" ssh -- "docker images -q dia.build-117.dev:latest" 2> /dev/null)" != "" ]]; then
            echo "YES"
        fi
        if [[ "$(minikube -p "${MINIKUBE_PROFILE}" ssh -- "docker images -q dia.build-119.dev:latest" 2> /dev/null)" == "" ]]; then
            echo "NO"
        fi
        ;;
    start)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" start \
                --kubernetes-version ${MINIKUBE_K8S_VERSION} \
                --driver ${MINIKUBE_DRIVER} \
                --memory ${MINIKUBE_HW_RAM} \
                --cpus ${MINIKUBE_HW_CPUS} \
                --disk-size ${MINIKUBE_HW_DISK_SIZE} \
                --mount-string="$(pwd):/mnt/diadata:rw" \
                --mount=true
            time (
                # TODO: this is only needed because minikube image build font return error exit code
                #   see https://github.com/kubernetes/minikube/issues/16576
                if [[ "$MINIKUBE_DRIVER" == "docker" ]]; then
                    eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"

                    # TODO: Use a dev specific image for development, instead of normal build image
                    # source ./baseimage.sh --notpush
                    # docker buildx build -f "build/Dockerfile-filtersBlockService" -t "diadata.filtersblockservice:latest" .

                    echo "Building base images ..."
                    # docker buildx build -f "build/build/Dockerfile-DiadataBuild-114-Dev" -t "dia.build-114.dev:latest" .
                    # echo "Base image build successfully [1/3]"
                    docker buildx build -f "build/build/Dockerfile-DiadataBuild-117-Dev" -t "dia.build-117.dev:latest" .
                    echo "Base image build successfully [1/1]"
                    # docker buildx build -f "build/build/Dockerfile-DiadataBuild-119-Dev" -t "dia.build-119.dev:latest" .
                    # echo "Base image build successfully [3/3]"
                    
                    echo "Building service images ..."
                    docker buildx build -f "build/Dockerfile-filtersBlockService-Dev" -t "dia.filtersblockservice.dev:latest" .
                    echo "Service image build successfully [1/3]"
                    docker buildx build -f "build/Dockerfile-tradesBlockService-Dev" -t "dia.tradesblockservice.dev:latest" .
                    echo "Service image build successfully [2/3]"
                    # docker buildx build -f "build/Dockerfile-pairDiscoveryService-Dev" -t "dia.pairdiscoveryservice.dev:latest" .
                    # echo "Service image build successfully [3/8]"
                    docker buildx build -f "build/Dockerfile-blockchainservice-Dev" -t "dia.blockchainservice.dev:latest" .
                    echo "Service image build successfully [3/3]"
                    # docker buildx build -f "build/Dockerfile-assetCollectionService-Dev" -t "dia.assetcollectionservice.dev:latest" .
                    # echo "Service image build successfully [5/8]"
                    # docker buildx build -f "build/Dockerfile-liquidityScraper-Dev" -t "dia.liquidityscraper.dev:latest" .
                    # echo "Service image build successfully [6/8]"
                    docker buildx build -f "build/Dockerfile-genericCollector-Dev" -t "dia.genericcollector.dev:latest" .
                    # echo "Service image build successfully [7/8]"
                    docker buildx build -f "build/Dockerfile-genericForeignScraper-Dev" -t "dia.genericforeignscraper.dev:latest" .
                    # echo "Service image build successfully [8/8]"
                    echo "All DIA's images build successfully"

                    eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
                else
                    minikube -p "${MINIKUBE_PROFILE}" image build -t us.icr.io/dia-registry/devops/build:latest -f build/build/Dockerfile-DiadataBuild .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t us.icr.io/dia-registry/devops/build-117:latest -f build/build/Dockerfile-DiadataBuild-117 .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.filtersblockservice:latest -f build/Dockerfile-filtersBlockService .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.tradesblockservice:latest -f build/Dockerfile-tradesBlockService .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.pairdiscoveryservice:latest -f build/Dockerfile-pairDiscoveryService .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.genericcollector:latest -f build/Dockerfile-genericCollector .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.blockchainservice:latest -f build/Dockerfile-blockchainservice .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.assetcollectionservice:latest -f build/Dockerfile-assetCollectionService .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.liquidityscraper:latest -f build/Dockerfile-liquidityScraper .
                    minikube -p "${MINIKUBE_PROFILE}" image build -t diadata.genericforeignscraper:latest -f build/Dockerfile-genericForeignScraper .
                fi
            )
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    stop)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" stop
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    delete)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube delete -p "${MINIKUBE_PROFILE}"
            docker image prune -a -f
            docker volume prune -a -f
            docker network prune -f
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    shell)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" ssh
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    logs)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" logs -f
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    clean)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker image prune -a -f
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker volume prune -f
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker network prune -f
            eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
            docker buildx prune -a -f
            eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    install)
        if [ "${#paths[@]}" -eq 1 ]; then
            echo "Creating and installing DIA's services ..."
            # TODO: Check if all images are built
            # TODO: Check if installation depends on a pre-built image or not
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/service-filtersblockservice.yaml
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/service-tradesblockservice.yaml
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-kafka.yaml
            # TODO: PostgreSQL data needs to be pruned
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-postgres-prepopulated.yaml
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-redis.yaml
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-influx.yaml
            echo "All DIA's services created with success"
        else
            if [ -n "${paths[1]:-}" ]; then
                if [ "${paths[1]}" == "full" ]; then
                    echo "Creating and installing DIA's services (on full mode) ..."
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/service-filtersblockservice.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/service-tradesblockservice.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-kafka.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create configmap postgres-schemma --from-file=deployments/config/pginit.sql
                    # TODO: PostgreSQL data needs to be pruned
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-postgres.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-redis.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/data-influx.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/job-prepare.yaml
                    echo "All DIA's services created with success"
                else
                    echo "Unknown command" >&2
                    exit 1
                fi
            fi
        fi
        ;;
    uninstall)
        if [ "${#paths[@]}" -eq 1 ]; then
            echo "Removing and un-installing DIA's services ..."
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/service-filtersblockservice.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/service-tradesblockservice.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/data-kafka.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/data-postgres-prepopulated.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/data-redis.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/data-influx.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/data-postgres.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete configmap postgres-schemma || true
            echo "All DIA's services removed with success"
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    psqlinsert)
        inputExchangeName="Custom"
        # echo "Exchange Name:"
        # read -r inputExchangeName
        # while true; do
        #     echo "The exchange is decentralized in a blockchain?"
        #     read -r inputExchangeCentralized
        #     case $inputExchangeCentralized in
        #         [Yy]* ) echo "You choose yes."; break;;
        #         [Nn]* ) echo "You choose no.";;
        #         * ) echo "Please answer yes or no.";;
        #     esac
        # done
        # echo "$inputExchangeCentralized"
        # while true; do
        #     echo "The exchange is a bridge?"
        #     read -r inputExchangeBridge
        #     case $inputExchangeBridge in
        #         [Yy]* ) echo "You choose yes."; break;;
        #         [Nn]* ) echo "You choose no.";;
        #         * ) echo "Please answer yes or no.";;
        #     esac
        # done
        # echo "$inputExchangeBridge"
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            exec deployment/postgres -- \
            psql -v ON_ERROR_STOP=on -U postgres \
            -c "INSERT INTO exchange (
                    exchange_id,
                    name,
                    centralized,
                    bridge,
                    contract,
                    blockchain,
                    rest_api,
                    ws_api,
                    pairs_api,
                    watchdog_delay,
                    scraper_active
                ) VALUES(
                    gen_random_uuid(),
                    'Custom',
                    true,
                    false,
                    '',
                    '',
                    '',
                    'wss://ws-feed.pro.coinbase.com',
                    'https://api.pro.coinbase.com/products',
                    300,
                    true
                )
                ;" >/dev/null 2>&1 && echo "Success" || echo "Error, a exchange with the name $inputExchangeName already exists." >&2
        # set +e
        # psqlExitCode=$?
        # if [ $psqlExitCode -ne 0 ]; then
        #     echo "Error, a exchange with the name $inputExchangeName already exists."
        # else
        #     echo "Success"
        # fi
        ;;
    psqldelete)
        # TODO: error handling when cannot delete row
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            exec deployment/postgres -- \
            psql -U postgres -t \
            -c "DELETE FROM exchange WHERE name = 'Custom'" >/dev/null 2>&1 && echo "Row deleted." || echo "Error, a exchange does not exists and cannot be deleted." >&2
        ;;
    psqlfind)
        # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
        #     exec deployment/postgres -- \
        #     psql -U postgres -t \
        #     -c "SELECT exchange_id FROM exchange WHERE name = 'Custom'" \
        #     -c "SELECT exchange_id FROM exchange WHERE name = 'Custom'"
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            exec deployment/postgres -- \
            psql -U postgres -t \
            -c "SELECT exchange_id FROM exchange WHERE name = 'Custom'" | if [[ $(wc -l) -ge 2 ]]; then echo "Found"; else echo "Not Found"; fi
        # -c "SELECT exchange_id FROM exchange WHERE name = 'Custom';
        #     IF NOT FOUND THEN RAISE EXCEPTION 'User not found'"
        # "select coalesce(
        #     (select name from exchange where name = 'CustomA'), '(none)'
        # )"
        # echo $?
        ;;
    create)
        if [ "${#paths[@]}" -gt 1 ]; then
            case "${paths[1]}" in
            exchange)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-custom.yaml
                ;;
            foreign)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-foreign-custom.yaml
                ;;
            cronjob)
                if [ "${#paths[@]}" -eq 2 ]; then
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create configmap postgres-entrypoint --from-file=deployments/config/postgres-docker-entrypoint.sh
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create configmap postgres-crondump --from-file=./scripts/dump.sh
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create secret docker-registry regcred \
                        --docker-server="https://registry.hub.docker.com/v2/" \
                        --docker-username="alex1a" \
                        --docker-password="R3Uf&nq@A9&hv&" \
                        --docker-email="alex.jorge.m@gmail.com"
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f "deployments/k8s-yaml/cronjob-snapshot.yaml"
                else
                    echo "Unknown command" >&2
                    exit 1
                fi
                ;;
            example)
                if [ "${#paths[@]}" -gt 2 ]; then
                    echo "Creating ${paths[2]} example ..."
                    case "${paths[2]}" in
                    exchange)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-bitfinex.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-bittrex.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-coinbase.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-mexc.yaml
                        ;;
                    liquidity)
                        # TODO: Move pod to job
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-liquidity-example-platypus.yaml
                        ;;
                    foreign)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-foreign-example-yahoofinance.yaml
                        ;;
                    foreign-dev)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-foreign-example-googlefinance-dev.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                    esac
                    echo "Example ${paths[2]} created with success"
                else
                    echo "Creating all examples ..."
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-bitfinex.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-bittrex.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-coinbase.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-exchange-example-mexc.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-liquidity-example-platypus.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- create -f deployments/k8s-yaml/scraper-foreign-example-yahoofinance.yaml
                    echo "All examples created"
                fi
                ;;
            *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    remove)
        if [ "${#paths[@]}" -gt 1 ]; then
            case "${paths[1]}" in
            exchange)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-custom.yaml
                ;;
            foreign)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-foreign-custom.yaml
                ;;
            cronjob)
                if [ "${#paths[@]}" -eq 2 ]; then
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f "deployments/k8s-yaml/cronjob-snapshot.yaml" || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete secret regcred || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete configmap postgres-entrypoint || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete configmap postgres-crondump || true
                else
                    echo "Unknown command" >&2
                    exit 1
                fi
                ;;
            example)
                if [ "${#paths[@]}" -gt 2 ]; then
                    echo "Removing ${paths[2]} example ..."
                    case "${paths[2]}" in
                    exchange)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-bitfinex.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-bittrex.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-coinbase.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-mexc.yaml
                        ;;
                    liquidity)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-liquidity-example-platypus.yaml
                        ;;
                    foreign)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-foreign-example-yahoofinance.yaml
                        ;;
                    foreign-dev)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-foreign-example-googlefinance-dev.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                    esac
                    echo "Example ${paths[2]} removed with success"
                else
                    echo "Removing all examples ..."
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-bitfinex.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-bittrex.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-coinbase.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-exchange-example-mexc.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-liquidity-example-platypus.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete -f deployments/k8s-yaml/scraper-foreign-example-yahoofinance.yaml
                    echo "All examples removed"
                fi
                ;;
            *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    code-lint)
        echo "Linting ..."
        golangci-lint run --config=./.golangci.yml --out-format=tab
        ;;
    code-test)
        echo "Testing ..."
        gotestsum --format pkgname
        ;;
    code-build)
        echo "Building ..."
        go build -v ./...
        ;;
    info)
        minikube profile list
        echo "PWD: $PWD"
        echo "SCRIPT_FOLDER: $SCRIPT_FOLDER"
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            echo "OSTYPE: GNU/Linux"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            echo "OSTYPE: Mac OSX"
        fi
        # TODO: uptime show the host uptime, not the minikube uptime
        #   https://stackoverflow.com/a/28353785/2042014
        uptime=$(minikube -p "${MINIKUBE_PROFILE}" ssh -- uptime -p)
        echo "Uptime: $uptime"
        echo; echo "Images:"
        minikube -p "${MINIKUBE_PROFILE}" image ls
        echo; echo "Status:"
        minikube -p "${MINIKUBE_PROFILE}" status
        echo; echo "Disk available:"
        minikube -p "${MINIKUBE_PROFILE}" ssh -- df -h
        if [[ "$MINIKUBE_DRIVER" == "docker" ]]; then
            echo; echo "Disk available of Docker:"
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker system df
        fi
        ;;
    ping)
        # TODO: Use job manifest instead kubectl run ??
        # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
        #     run x --image=influxdb:1.8 --restart=Never --command -- \
        #     influx -host 'data-influx.default.svc.cluster.local' -port '8086' -execute 'SHOW DATABASES'
        echo "Ping tests:"
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-redis.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-redis.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-redis >/dev/null 2>&1 && echo "  Redis OK" || echo "  Redis FAILED" >&2
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-influx.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-influx.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-influx >/dev/null 2>&1 && echo "  InfluxDB OK" || echo "  InfluxDB FAILED" >&2
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-postgres.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-postgres.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-postgres >/dev/null 2>&1 && echo "  PostgreSQL OK" || echo "  PostgreSQL FAILED" >&2
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-kafka.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-kafka.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-kafka >/dev/null 2>&1 && echo "  Kafka OK" || echo "  Kafka FAILED" >&2
        ;;
    data-reset)
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            exec deployment/data-influx -- \
            influx -host 'localhost' -port '8086' -database 'dia' -execute 'DROP MEASUREMENT foreignquotation'
        ;;
    data-list)
        if [ "${#paths[@]}" -gt 1 ]; then
            case "${paths[1]}" in
            exchange)
                echo "Exchange:"
                read -r inputExchangeName
                echo "PostgreSQL Data:"
                echo "  Name: $inputExchangeName"
                is_centralized=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -AXqt \
                    -c "SELECT centralized FROM exchange WHERE name = '$inputExchangeName'" | sed 's/\r$//')
                echo "  Centralized: $is_centralized"
                is_bridge=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT bridge FROM exchange WHERE name = '$inputExchangeName'")
                echo "  Bridge: $is_bridge"
                is_active=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT scraper_active FROM exchange WHERE name = '$inputExchangeName'")
                echo "  Active: $is_active"
                if [[ "$is_centralized" == "t" ]]; then
                    num_exchangepairs=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM exchangepair WHERE exchange = '$inputExchangeName'")
                    echo "  Num. of exchange pairs: $num_exchangepairs"
                    num_exchangepairassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM asset WHERE asset_id IN (SELECT id_quotetoken FROM exchangepair WHERE exchange = '$inputExchangeName') OR asset_id IN (SELECT id_basetoken FROM exchangepair WHERE exchange = '$inputExchangeName')")
                    echo "    Num. of assets: $num_exchangepairassets"
                    num_exchangesymbols=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM exchangesymbol WHERE exchange = '$inputExchangeName'")
                    echo "  Num. of exchange symbols: $num_exchangesymbols"
                    num_exchangesymbolsassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM asset WHERE asset_id IN (SELECT asset_id FROM exchangesymbol WHERE exchange = '$inputExchangeName')")
                    echo "    Num. of assets: $num_exchangesymbolsassets"
                else
                    blockchain=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT blockchain FROM exchange WHERE name = '$inputExchangeName'")
                    echo "  Blockchain: $blockchain"
                    num_pools=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM pool WHERE exchange = '$inputExchangeName'")
                    echo "  Num. of pools: $num_pools"
                    num_poolassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM poolasset WHERE pool_id IN (SELECT pool_id FROM pool WHERE exchange = '$inputExchangeName')")
                    echo "    Num. of pool assets: $num_poolassets"
                    num_poolassetsassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM asset WHERE asset_id IN (SELECT asset_id FROM poolasset WHERE pool_id IN (SELECT pool_id FROM pool WHERE exchange = '$inputExchangeName'))")
                    echo "      Num. of assets: $num_poolassetsassets"
                fi
                ;;
            blockchain)
                echo "Blockchain:"
                read -r inputBlockchainName
                echo "PostgreSQL Data:"
                verificationmechanism=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT verificationmechanism FROM blockchain WHERE name = '$inputBlockchainName'")
                echo "  Consensus: $verificationmechanism"
                genesisdate=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT genesisdate FROM blockchain WHERE name = '$inputBlockchainName'")
                echo "  Genesis Date: $genesisdate"
                chainid=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT chain_id FROM blockchain WHERE name = '$inputBlockchainName'")
                echo "  Chain ID: $chainid"
                num_blockchainassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT COUNT(*) FROM asset WHERE blockchain = '$inputBlockchainName'")
                echo "  Num. of blockchain assets: $num_blockchainassets"
                ;;
            *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            # TODO: SELECT * of Influx data is very slow, maybe use COUNT
            echo "InfluxDB Data:"
            num_tradestmp=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM tradesTmp' | wc -l)
            echo "  Num. of tradesTmp: $num_tradestmp"
            num_filters=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM filters' | wc -l)
            echo "  Num. of filters: $num_filters"
            num_quotations=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM assetQuotations' | wc -l)
            echo "  Num. of quotations: $num_quotations"
            num_foreignquotation=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM foreignquotation' | wc -l)
            echo "  Num. of foreign quotations: $num_foreignquotation"
            # TODO: not working, getting stuck
            echo "PostgreSQL Data:"
            num_exchanges=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM exchange")
            echo "  Num. of exchanges: $num_exchanges"
            num_pools=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM pool")
            echo "  Num. of pools: $num_pools"
            num_poolassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM poolasset")
            echo "  Num. of pool assets: $num_poolassets"
            num_assets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM asset")
            echo "  Num. of assets: $num_assets"
            num_exchangepairs=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM exchangepair")
            echo "  Num. of exchange pairs: $num_exchangepairs"
            num_exchangesymbols=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM exchangesymbol")
            echo "  Num. of exchange symbols: $num_exchangesymbols"
        fi
        ;;
    *)
        echo "Unknown command" >&2
        exit 1
        ;;
    esac
}

main "$@"