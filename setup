#!/usr/bin/env bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  SCRIPT_FOLDER="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$SCRIPT_FOLDER/$SOURCE"
done
SCRIPT_FOLDER="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
unset SOURCE

# echo "$PWD"
# echo "$SCRIPT_FOLDER"

# if [[ "$OSTYPE" == "linux-gnu"* ]]; then
#     echo "GNU/Linux"
# elif [[ "$OSTYPE" == "darwin"* ]]; then
#     echo "Mac OSX"
# else
#     echo "Unknown operating system"
#     exit 1
# fi

###############################################################################

function usage()
{
    echo "Usage: setup [OPTIONS] PATH"
    echo
    echo "Options:"
    echo
    echo "  -h --help         Print help"
    echo "  -g --goto <alias> Goto specified alias before edit"
    echo "  -n --nodetached   Don't try to run in a detached window"
    echo "  -s --session      Attach to a tmux session"
    echo
    echo "Report bugs to: <https://github.com/ljmf00/dotfiles/issues>"
}

function main()
{
    local paths=()
    local args=
    args=$(getopt -o hnsg:                                \
                   --long goto:,nodetached,nosession,help \
                   -n 'setup' -- "$@"                    \
          )

    # shellcheck disable=SC2181
    if [ $? != 0 ] ; then usage 1>&2; return 1; fi

    set -euo pipefail
    eval set -- "$args"

    while true; do
        case "$1" in
            --session | -s )
                insession=true
                shift ;;
            --goto | -g    )
                galias="$2"

                # shellcheck disable=SC1090
                source "$HOME/.oh-luis-bash/goto-command.sh"

                gpath="$(goto -x "$galias" 2>/dev/null)"
                if [ "$gpath" = "" ]; then
                    echo "Invalid foto alias!" >&2
                    return 1
                fi

                shift 2 ;;
            --nodetached | -n )
                detached=false
                shift ;;
            --help | -h     ) usage; return 0 ;;
            --              ) shift; break    ;;
            *               )        break    ;;
        esac
    done

    # expand paths after parsing
    paths=( "$@" )

    # echo "${#paths[@]}"
    # echo "${paths[@]}"
    # echo "${paths:-.}"
    # echo "${paths[0]}"
    # echo "${paths[1]}"

    if [ -f "${paths:-.}" ] || [ "${#paths[@]}" -gt 1 ]; then
        edit_args=()
    fi

    # build_version = $(call sha,$(build_path)/build-image/Dockerfile)
    # build_tag = agones-build:$(build_version)

    MINIKUBE_PROFILE=dia
    MINIKUBE_K8S_VERSION=v1.25.7
    MINIKUBE_HW_DISK_SIZE=50g
    MINIKUBE_HW_CPUS=4
    MINIKUBE_HW_RAM=8g
    MINIKUBE_DRIVER=docker
    MINIKUBE_CERT_MOUNT=~/.minikube
    # kubectl configuration to use
    KUBECONFIG=~/.kube/config

    case "${paths[0]}" in
        minikube-start)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} start \
                    --kubernetes-version ${MINIKUBE_K8S_VERSION} \
                    --driver ${MINIKUBE_DRIVER} \
                    --memory ${MINIKUBE_HW_RAM} \
                    --cpus ${MINIKUBE_HW_CPUS} \
                    --disk-size ${MINIKUBE_HW_DISK_SIZE}
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-stop)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} stop
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-shell)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} ssh
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-log)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} logs -f
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-info)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube profile list
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-status)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} status
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-image-list | minikube-image-ls)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} image ls
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-delete)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube delete -p ${MINIKUBE_PROFILE}
                # TODO: remove all minikube mount files
                # rm -rf ./.temp-tester/
                docker image prune -a -f
                docker volume prune -a -f
                docker network prune -f
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-build)
            if [ "${#paths[@]}" -eq 1 ]; then
                # echo "Building minikube images ..."
                # images_needed=(
                #     "us.icr.io/dia-registry/devops/build:latest"
                #     "us.icr.io/dia-registry/devops/build-117:latest"
                #     "docker.io/library/diadata.filtersblockservice:latest"
                #     "docker.io/library/diadata.tradesblockservice:latest"
                # )
                # minikube_images=$(minikube -p ${MINIKUBE_PROFILE} image ls)
                # for image_needed in "${images_needed[@]}"; do
                #     for minikube_image in $minikube_images; do
                #         if [ "$image_needed" = "$minikube_image" ]; then
                #             echo "Image $image_needed found in minikube"
                #         fi
                #     done
                # done
                # echo "${@:0}"
                # echo "${@:1}"
                # echo "${@:2}"
                # sha256sum README.md | head -c 10
                minikube -p ${MINIKUBE_PROFILE} image build -t us.icr.io/dia-registry/devops/build:latest -f build/build/Dockerfile-DiadataBuild .
                minikube -p ${MINIKUBE_PROFILE} image build -t us.icr.io/dia-registry/devops/build-117:latest -f build/build/Dockerfile-DiadataBuild-117 .
                minikube -p ${MINIKUBE_PROFILE} image build -t diadata.filtersblockservice:latest -f build/Dockerfile-filtersBlockService .
                minikube -p ${MINIKUBE_PROFILE} image build -t diadata.tradesblockservice:latest -f build/Dockerfile-tradesBlockService .
                minikube -p ${MINIKUBE_PROFILE} image build -t diadata.pairdiscoveryservice:latest -f build/Dockerfile-pairDiscoveryService .
                minikube -p ${MINIKUBE_PROFILE} image build -t diadata.exchangescrapercollector:latest -f build/Dockerfile-genericCollector .
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-installfull)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/filtersblockservice.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/tradesblockservice.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/kafka.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/postgres.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/redis.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/influx.yaml
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-uninstallfull)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/filtersblockservice.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/tradesblockservice.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/kafka.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/postgres.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/redis.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/influx.yaml
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-ping)
            minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/influx -- \
                influx -host 'localhost' -port '8086' -execute 'SHOW DATABASES' >/dev/null 2>&1 && echo "InfluxDB OK" || echo "InfluxDB FAILED" >&2
            ;;
        minikube-tradeslist)
            num_trades=$(minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM tradesTmp' | wc -l)
            echo "Number of trades: $num_trades"
            num_quotations=$(minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM assetQuotations' | wc -l)
            echo "Number of quotations: $num_quotations"
            num_filters=$(minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' -execute 'SELECT * FROM filters' | wc -l)
            echo "Number of filters: $num_filters"
            ;;
        minikube-install)
            if [ "${#paths[@]}" -eq 1 ]; then
                # TODO: Check if all images are built
                # TODO: Check if installation depends on a pre-built image or not
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/filtersblockservice.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/tradesblockservice-prepopulated.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/kafka.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/postgres-prepopulated.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/redis.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/influx.yaml
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-uninstall)
            if [ "${#paths[@]}" -eq 1 ]; then
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/filtersblockservice.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/tradesblockservice-prepopulated.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/kafka.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/postgres-prepopulated.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/redis.yaml
                minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/influx.yaml
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-psqlinsert)
            inputExchangeName="Custom"
            # echo "Exchange Name:"
            # read -r inputExchangeName
            # while true; do
            #     echo "The exchange is decentralized in a blockchain?"
            #     read -r inputExchangeCentralized
            #     case $inputExchangeCentralized in
            #         [Yy]* ) echo "You choose yes."; break;;
            #         [Nn]* ) echo "You choose no.";;
            #         * ) echo "Please answer yes or no.";;
            #     esac
            # done
            # echo "$inputExchangeCentralized"
            # while true; do
            #     echo "The exchange is a bridge?"
            #     read -r inputExchangeBridge
            #     case $inputExchangeBridge in
            #         [Yy]* ) echo "You choose yes."; break;;
            #         [Nn]* ) echo "You choose no.";;
            #         * ) echo "Please answer yes or no.";;
            #     esac
            # done
            # echo "$inputExchangeBridge"
            minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/postgres -- \
                psql -v ON_ERROR_STOP=on -U postgres \
                -c "INSERT INTO exchange (
                    exchange_id,
                    name,
                    centralized,
                    bridge,
                    contract,
                    blockchain,
                    rest_api,
                    ws_api,
                    pairs_api,
                    watchdog_delay,
                    scraper_active
                ) VALUES(
                    gen_random_uuid(),
                    'Custom',
                    true,
                    false,
                    '',
                    '',
                    '',
                    'wss://ws-feed.pro.coinbase.com',
                    'https://api.pro.coinbase.com/products',
                    300,
                    true
                )
                ;" >/dev/null 2>&1 && echo "Success" || echo "Error, a exchange with the name $inputExchangeName already exists." >&2
            # set +e
            # psqlExitCode=$?
            # if [ $psqlExitCode -ne 0 ]; then
            #     echo "Error, a exchange with the name $inputExchangeName already exists."
            # else
            #     echo "Success"
            # fi
            ;;
        minikube-psqldelete)
            # TODO: error handling when cannot delete row
            minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/postgres -- \
                psql -U postgres -t \
                -c "DELETE FROM exchange WHERE name = 'Custom'" >/dev/null 2>&1 && echo "Row deleted." || echo "Error, a exchange does not exists and cannot be deleted." >&2
            ;;
        minikube-psqlfind)
            # minikube -p ${MINIKUBE_PROFILE} kubectl -- \
            #     exec -it deployment/postgres -- \
            #     psql -U postgres -t \
            #     -c "SELECT exchange_id FROM exchange WHERE name = 'Custom'" \
            #     -c "SELECT exchange_id FROM exchange WHERE name = 'Custom'"
            minikube -p ${MINIKUBE_PROFILE} kubectl -- \
                exec -it deployment/postgres -- \
                psql -U postgres -t \
                -c "SELECT exchange_id FROM exchange WHERE name = 'Custom'" | if [[ $(wc -l) -ge 2 ]]; then echo "Found"; else echo "Not Found"; fi
                # -c "SELECT exchange_id FROM exchange WHERE name = 'Custom';
                #     IF NOT FOUND THEN RAISE EXCEPTION 'User not found'"
                # "select coalesce(
                #     (select name from exchange where name = 'CustomA'), '(none)'
                # )"
            # echo $?
            ;;
        minikube-create)
            if [ "${#paths[@]}" -gt 1 ]; then
                echo "${#paths[@]}"
                case "${paths[1]}" in
                    exchange)
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/exchangescraper-custom.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                esac
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-create-example)
            if [ "${#paths[@]}" -gt 1 ]; then
                case "${paths[1]}" in
                    exchange)
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/exchangescraper-example-bitfinex.yaml
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/exchangescraper-example-bittrex.yaml
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/exchangescraper-example-coinbase.yaml
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- create -f deployments/k8s-yaml/exchangescraper-example-mexc.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                esac
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-remove)
            if [ "${#paths[@]}" -gt 1 ]; then
                echo "${#paths[@]}"
                case "${paths[1]}" in
                    exchange)
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/exchangescraper-custom.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                esac
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        minikube-remove-example)
            if [ "${#paths[@]}" -gt 1 ]; then
                case "${paths[1]}" in
                    exchange)
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/exchangescraper-example-bitfinex.yaml
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/exchangescraper-example-bittrex.yaml
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/exchangescraper-example-coinbase.yaml
                        minikube -p ${MINIKUBE_PROFILE} kubectl -- delete -f deployments/k8s-yaml/exchangescraper-example-mexc.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                esac
            else
                echo "Unknown command" >&2
                exit 1
            fi
            ;;
        recreate)
            docker_service drop "${@:2}"
            docker_service start "${@:2}"
            ;;
        drop)
            docker compose -f ~/dotfiles/dist/deploy/compose.yaml rm -svf "${@:2}"
            ;;
        status)
            docker compose -f ~/dotfiles/dist/deploy/compose.yaml ps "${@:2}"
            ;;
        build)
            docker compose -f ~/dotfiles/dist/deploy/compose.yaml build --pull --progress plain "${@:2}"
            ;;
        *)
            echo "Unknown command" >&2
            exit 1
            ;;
    esac
}

main "$@"