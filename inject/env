#!/usr/bin/env bash

# This script is used to manage the DIA development environment
# It is used to start, stop, build, install, uninstall, etc. the DIA platform
# It is also used to manage the DIA platform resources

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
    SCRIPT_FOLDER="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$SCRIPT_FOLDER/$SOURCE"
done
SCRIPT_FOLDER="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
unset SOURCE

###############################################################################

function usage() {
    echo "The DIA enviorment manager"
    echo
    echo "Environment variables:"
    echo
    echo "| Name                    | Description                 |"
    echo "|-------------------------|-----------------------------|"
    echo "| MINIKUBE_PROFILE        | Minikube profile name       |"
    echo "| MINIKUBE_HW_DISK_SIZE   | Minikube disk size          |"
    echo "| MINIKUBE_HW_CPUS        | Minikube number of CPUs     |"
    echo "| MINIKUBE_HW_RAM         | Minikube memory limit       |"
    echo "| MINIKUBE_K8S_VERSION    | K8s version                 |"
    echo
    echo "Usage:"
    echo "  env [OPTIONS] COMMAND [ARGS]..."
    echo
    echo "Options:"
    echo "  -h --help             Print help"
    echo
    echo "Available commands:"
    echo "  code-build            Build platform code"
    echo "  code-lint             Lint code"
    echo "  code-test             Run tests"
    echo "  start                 Start cluster"
    echo "  stop                  Stop the cluster"
    echo "  delete                Delete all cluster resources"
    echo "  install [full]        Install DIA platform"
    echo "  uninstall             Un-install DIA platform"
    echo "  create                Create a new resource"
    echo "  remove                Remove a resource"
    echo "  clean                 Clean unused files"
    echo "  info                  Show detailed information"
    echo "  shell                 Connect to enviornment shell"
    echo "  logs                  Print logs"
    echo "  ping                  Make ping tests"
    echo "  data-list             List data"
    echo "  data-reset            Reset data"
    echo
    echo "Report bugs to: <https://github.com/diadata-org/diadata/issues>"
}

function main() {
    local full=false

    local paths=()
    local args=
    args=$(
        getopt -o hnsp: \
            --long parameter:,disk-space:,nodetached,full,help \
            -n 'env' -- "$@"
    )
    local version_detected=$(git describe --tags --abbrev=0)

    # shellcheck disable=SC2181
    if [ $? != 0 ]; then
        usage 1>&2
        return 1
    fi

    set -euo pipefail

    eval set -- "$args"

    while true; do
        case "$1" in
        --full | -f)
            full=true
            shift ;;
        # TODO: remove until serve as example
        --parameter | -p)
            parameter="$2"
            if [ "$parameter" = "" ]; then
                echo "Invalid parameter!" >&2
                return 1
            fi
            echo "Parameter: $parameter"

            ;;
            --help | -h     ) usage; return 0 ;;
            --              ) shift; break    ;;
            *               )        break    ;;
        esac
    done

    # expand paths after parsing
    paths=("$@")

    if ! hash git 2> /dev/null; then echo "Git not found" >&2; return 1; fi
    if ! hash jq 2> /dev/null; then echo "jq not found" >&2; return 1; fi
    # TODO: Uncomment when needed
    # if ! hash yq 2> /dev/null; then echo "yq not found" >&2; return 1; fi
    # if ! hash helm 2> /dev/null; then echo "Helm not found" >&2; return 1; fi
    if ! hash docker 2> /dev/null; then echo "Docker not found" >&2; return 1; fi
    if ! hash minikube 2> /dev/null; then echo "Minikube not found" >&2; return 1; fi
    # TODO: Uncomment when needed
    # if ! hash golangci-lint 2> /dev/null; then echo "golangci-lint not found" >&2; return 1; fi

    # echo "${#paths[@]}"
    # echo "${paths[@]}"
    # echo "${paths:-.}"
    # echo "${paths[0]}"
    # echo "${paths[1]}"

    if [ -f "${paths:-.}" ] || [ "${#paths[@]}" -gt 1 ]; then
        edit_args=()
    fi

    if [[ "$OSTYPE" != "linux-gnu"* ]] && [[ "$OSTYPE" != "darwin"* ]]; then
        echo "Unknown operating system"
        exit 1
    fi

    MINIKUBE_PROFILE=dia
    MINIKUBE_K8S_VERSION=v1.25.7
    MINIKUBE_HW_DISK_SIZE=50g
    MINIKUBE_HW_CPUS=4
    MINIKUBE_HW_RAM=8g
    MINIKUBE_DRIVER=docker
    SNAPSHOT_DOCKER_REGISTRY=https://registry.hub.docker.com/v2/
    SNAPSHOT_DOCKER_USERNAME=dia_contributor
    SNAPSHOT_DOCKER_PASSWORD=dia_contributor_pw
    SNAPSHOT_DOCKER_EMAIL=dia_contributor@example.com
    # TODO: Cert manager will work with this
    # MINIKUBE_CERT_MOUNT=~/.minikube
    # TODO: This will be needed when managing multiple clusters
    # KUBECONFIG=~/.kube/config

    if [ -f "./.env.local" ]; then echo "Sourcing local config file ..."; source ./.env.local; fi

    if [ ! -n "${paths[0]:-}" ]; then
        echo "No command specified" >&2
        exit 1
    fi
    case "${paths[0]}" in
    start)
        if [ "${#paths[@]}" -eq 1 ]; then
            echo "DIA Version: $version_detected"
            echo "Num. CPUs: ${MINIKUBE_HW_CPUS}"
            echo "Disk size: ${MINIKUBE_HW_DISK_SIZE}"
            echo "Memory: ${MINIKUBE_HW_RAM}"
            echo "K8s version: ${MINIKUBE_K8S_VERSION}"
            echo "Docker version: v$(docker version --format '{{.Client.Version}}')"
            echo "Minikube driver: ${MINIKUBE_DRIVER}"
            echo "Minikube profile: ${MINIKUBE_PROFILE}"
            minikube version
            
            echo "Starting Minikube cluster ..."
            cluster_name=$(minikube profile list --output json | jq -r -c '.valid | .[] | .Name')
            cluster_status=$(minikube profile list --output json | jq -r -c '.valid | .[] | .Status')
            if [[ "$cluster_name" != "${MINIKUBE_PROFILE}" || "$cluster_status" != "Running" ]]; then
                # Start minikube cluster
                minikube -p "${MINIKUBE_PROFILE}" start \
                    --kubernetes-version ${MINIKUBE_K8S_VERSION} \
                    --driver ${MINIKUBE_DRIVER} \
                    --memory ${MINIKUBE_HW_RAM} \
                    --cpus ${MINIKUBE_HW_CPUS} \
                    --disk-size ${MINIKUBE_HW_DISK_SIZE} \
                    --mount-string="$(pwd):/mnt/diadata" \
                    --mount
            else
                echo "Minikube cluster already running"
            fi

            # TODO: Installing DIA Helm chart
            # minikube -p "${MINIKUBE_PROFILE}" kubectl get namespace | grep -q "^dia " || kubectl create namespace "dia"
            # helm repo update
            # helm upgrade "dia-release" --namespace "dia-system" --create-namespace --install \
            #     --set "exchangescrapers.namespaces={default,dia}" "./deployments/helm/dia"

            # TODO: this is only needed because minikube image build font return error exit code
            #   see https://github.com/kubernetes/minikube/issues/16576
            if [[ "$MINIKUBE_DRIVER" == "docker" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                echo "Building base images ..."
                docker buildx build -f "build/build/Dockerfile-DiadataBuild-117-Dev" \
                    -t "dia.build-117.dev:latest" .
                echo "Base image build successfully [1/1]"
                # docker buildx build -f "build/build/Dockerfile-DiadataBuild-114-Dev" \
                #     -t "dia.build-114.dev:latest" .
                # echo "Base image build successfully [X/Y]"
                # docker buildx build -f "build/build/Dockerfile-DiadataBuild-119-Dev" \
                #     -t "dia.build-119.dev:latest" .
                # echo "Base image build successfully [X/Y]"
                echo "All DIA's images build successfully"
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            else
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t us.icr.io/dia-registry/devops/build:latest \
                    -f build/build/Dockerfile-DiadataBuild .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t us.icr.io/dia-registry/devops/build-117:latest \
                    -f build/build/Dockerfile-DiadataBuild-117 .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.filtersblockservice:latest \
                    -f build/Dockerfile-filtersBlockService .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.tradesblockservice:latest \
                    -f build/Dockerfile-tradesBlockService .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.pairdiscoveryservice:latest \
                    -f build/Dockerfile-pairDiscoveryService .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.genericcollector:latest \
                    -f build/Dockerfile-genericCollector .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.blockchainservice:latest \
                    -f build/Dockerfile-blockchainservice .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.assetcollectionservice:latest \
                    -f build/Dockerfile-assetCollectionService .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.liquidityscraper:latest \
                    -f build/Dockerfile-liquidityScraper .
                minikube -p "${MINIKUBE_PROFILE}" \
                    image build -t diadata.genericforeignscraper:latest \
                    -f build/Dockerfile-genericForeignScraper .
            fi
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    stop)
        if [ "${#paths[@]}" -eq 1 ]; then
            echo "Stopping cluster to ${MINIKUBE_PROFILE} profile ..."
            minikube -p "${MINIKUBE_PROFILE}" stop
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    delete)
        if [ "${#paths[@]}" -eq 1 ]; then
            echo "Deleting cluster and cleaning files ..."
            minikube delete -p "${MINIKUBE_PROFILE}"
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    shell)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" ssh
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    logs)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" logs -f
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    clean)
        if [ "${#paths[@]}" -eq 1 ]; then
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker image prune -a -f
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker volume prune -f
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker network prune -f
            eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
            docker buildx prune -a -f
            eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    install)
        if [ "${#paths[@]}" -eq 1 ]; then
            
            echo "Creating and installing DIA's services ..."

            docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                "docker images -q dia.filtersblockservice.dev:latest" 2> /dev/null)"
            if [[ "${docker_query}" == "" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                docker buildx build -f "build/Dockerfile-filtersBlockService-Dev" \
                    -t "dia.filtersblockservice.dev:latest" .
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            fi
            echo "Service image present [1/2]"

            docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                "docker images -q dia.tradesblockservice.dev:latest" 2> /dev/null)"
            if [[ "${docker_query}" == "" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                docker buildx build -f "build/Dockerfile-tradesBlockService-Dev" \
                    -t "dia.tradesblockservice.dev:latest" .
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            fi
            echo "Service image present [2/2]"

            # Install DIA's services
            minikube -p "${MINIKUBE_PROFILE}" \
                kubectl -- create -f deployments/k8s-yaml/service-filtersblockservice.yaml
            minikube -p "${MINIKUBE_PROFILE}" \
                kubectl -- create -f deployments/k8s-yaml/service-tradesblockservice.yaml

            # Install Kafka and Zookeeper
            minikube -p "${MINIKUBE_PROFILE}" \
                kubectl -- create -f deployments/k8s-yaml/data-kafka.yaml

            # Install PostgreSQL
            minikube -p "${MINIKUBE_PROFILE}" \
                kubectl -- create -f deployments/k8s-yaml/data-postgres-prepopulated.yaml

            # Install Redis
            minikube -p "${MINIKUBE_PROFILE}" \
                kubectl -- create -f deployments/k8s-yaml/data-redis.yaml

            # Install InfluxDB
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                create -f deployments/k8s-yaml/data-influx.yaml

            echo "All DIA's services created with success"
        else
            if [ -n "${paths[1]:-}" ]; then
                if [ "${paths[1]}" == "full" ]; then
                    echo "Creating and installing DIA's services (on full mode) ..."
                    docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                        "docker images -q dia.filtersblockservice.dev:latest" 2> /dev/null)"
                    if [[ "${docker_query}" == "" ]]; then
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                        docker buildx build -f "build/Dockerfile-filtersBlockService-Dev" \
                            -t "dia.filtersblockservice.dev:latest" .
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
                    fi
                    echo "Service image present [1/4]"

                    docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                        "docker images -q dia.tradesblockservice.dev:latest" 2> /dev/null)"
                    if [[ "${docker_query}" == "" ]]; then
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                        docker buildx build -f "build/Dockerfile-tradesBlockService-Dev" \
                            -t "dia.tradesblockservice.dev:latest" .
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
                    fi
                    echo "Service image present [2/4]"

                    docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                        "docker images -q dia.blockchainservice.dev:latest" 2> /dev/null)"
                    if [[ "${docker_query}" == "" ]]; then
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                        docker buildx build -f "build/Dockerfile-blockchainservice-Dev" \
                            -t "dia.blockchainservice.dev:latest" .
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
                    fi
                    echo "Service image present [3/4]"

                    docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                        "docker images -q dia.assetcollectionservice.dev:latest" 2> /dev/null)"
                    if [[ "${docker_query}" == "" ]]; then
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                        docker buildx build -f "build/Dockerfile-assetCollectionService-Dev" \
                            -t "dia.assetcollectionservice.dev:latest" .
                        eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
                    fi
                    echo "Service image present [4/4]"

                    # Install DIAs services
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/service-filtersblockservice.yaml
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/service-tradesblockservice.yaml

                    # Install Kafka and Zookeeper
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/data-kafka.yaml

                    # Install PostgreSQL
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create configmap postgres-schemma \
                        --from-file=deployments/config/pginit.sql
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/data-postgres.yaml

                    # Install Redis
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/data-redis.yaml

                    # Install InfluxDB
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/data-influx.yaml

                    # Install the preparation job
                    minikube -p "${MINIKUBE_PROFILE}" \
                        kubectl -- create -f deployments/k8s-yaml/job-prepare.yaml
                    echo "All DIA's services created with success"
                else
                    echo "Unknown command" >&2
                    exit 1
                fi
            fi
        fi
        ;;
    uninstall)
        if [ "${#paths[@]}" -eq 1 ]; then
            echo "Removing and un-installing DIA's services ..."
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/service-filtersblockservice.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/service-tradesblockservice.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/data-kafka.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/data-postgres-prepopulated.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/data-redis.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/data-influx.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete -f deployments/k8s-yaml/data-postgres.yaml || true
            minikube -p "${MINIKUBE_PROFILE}" kubectl \
                -- delete configmap postgres-schemma || true
            echo "All DIA's services removed with success"
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    create)
        # inputExchangeName="Custom"
        # echo "Exchange Name:"
        # read -r inputExchangeName
        # while true; do
        #     echo "The exchange is decentralized in a blockchain?"
        #     read -r inputExchangeCentralized
        #     case $inputExchangeCentralized in
        #         [Yy]* ) echo "You choose yes."; break;;
        #         [Nn]* ) echo "You choose no.";;
        #         * ) echo "Please answer yes or no.";;
        #     esac
        # done
        # echo "$inputExchangeCentralized"
        # while true; do
        #     echo "The exchange is a bridge?"
        #     read -r inputExchangeBridge
        #     case $inputExchangeBridge in
        #         [Yy]* ) echo "You choose yes."; break;;
        #         [Nn]* ) echo "You choose no.";;
        #         * ) echo "Please answer yes or no.";;
        #     esac
        # done
        # echo "$inputExchangeBridge"
        # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
        #     exec deployment/postgres -- \
        #     psql -v ON_ERROR_STOP=on -U postgres \
        #     -c "INSERT INTO exchange (
        #             exchange_id,
        #             name,
        #             centralized,
        #             bridge,
        #             contract,
        #             blockchain,
        #             rest_api,
        #             ws_api,
        #             pairs_api,
        #             watchdog_delay,
        #             scraper_active
        #         ) VALUES(
        #             gen_random_uuid(),
        #             'Custom',
        #             true,
        #             false,
        #             '',
        #             '',
        #             '',
        #             'wss://ws-feed.pro.coinbase.com',
        #             'https://api.pro.coinbase.com/products',
        #             300,
        #             true
        #         )
        #         ;" >/dev/null 2>&1 \
        #     && echo "Success" \
        #     || echo "Error, a exchange with the name $inputExchangeName already exists." >&2
        # set +e
        # psqlExitCode=$?
        # if [ $psqlExitCode -ne 0 ]; then
        #     echo "Error, a exchange with the name $inputExchangeName already exists."
        # else
        #     echo "Success"
        # fi
        if [ "${#paths[@]}" -gt 1 ]; then
            echo "Checking if services images are present ..."
            docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                "docker images -q dia.pairdiscoveryservice.dev:latest" 2> /dev/null)"
            if [[ "${docker_query}" == "" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                docker buildx build -f "build/Dockerfile-pairDiscoveryService-Dev" \
                    -t "dia.pairdiscoveryservice.dev:latest" .
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            fi
            echo "Service image present [1/4]"

            docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                "docker images -q dia.genericcollector.dev:latest" 2> /dev/null)"
            if [[ "${docker_query}" == "" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                docker buildx build -f "build/Dockerfile-genericCollector-Dev" \
                    -t "dia.genericcollector.dev:latest" .
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            fi
            echo "Service image present [2/4]"

            docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                "docker images -q dia.genericforeignscraper.dev:latest" 2> /dev/null)"
            if [[ "${docker_query}" == "" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                docker buildx build -f "build/Dockerfile-genericForeignScraper-Dev" \
                    -t "dia.genericforeignscraper.dev:latest" .
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            fi
            echo "Service image present [3/4]"

            docker_query="$(minikube -p "${MINIKUBE_PROFILE}" ssh -- \
                "docker images -q dia.liquidityscraper.dev:latest" 2> /dev/null)"
            if [[ "${docker_query}" == "" ]]; then
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
                docker buildx build -f "build/Dockerfile-liquidityScraper-Dev" \
                    -t "dia.liquidityscraper.dev:latest" .
                eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env --unset)"
            fi
            echo "Service image present [4/4]"

            case "${paths[1]}" in
            exchange)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    create -f deployments/k8s-yaml/scraper-cex.yaml
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    create -f deployments/k8s-yaml/scraper-dex.yaml
                ;;
            foreign)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    create -f deployments/k8s-yaml/scraper-foreign.yaml
                ;;
            liquidity)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    create -f deployments/k8s-yaml/scraper-liquidity.yaml
                ;;
            cronjob)
                if [ "${#paths[@]}" -eq 2 ]; then
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create configmap postgres-entrypoint \
                        --from-file=deployments/config/postgres-docker-entrypoint.sh
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create configmap postgres-crondump --from-file=./scripts/dump.sh
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create secret docker-registry regcred \
                        --docker-server="${SNAPSHOT_DOCKER_REGISTRY}" \
                        --docker-username="${SNAPSHOT_DOCKER_USERNAME}" \
                        --docker-password="${SNAPSHOT_DOCKER_PASSWORD}" \
                        --docker-email="${SNAPSHOT_DOCKER_EMAIL}"
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f "deployments/k8s-yaml/cronjob-snapshot.yaml"
                else
                    echo "Unknown command" >&2
                    exit 1
                fi
                ;;
            example)
                if [ "${#paths[@]}" -gt 2 ]; then
                    echo "Creating ${paths[2]} example ..."
                    case "${paths[2]}" in
                    exchange)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-cex-bitfinex.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-cex-bittrex.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-cex-coinbase.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-cex-mexc.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-cex-bitmart.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-dex-platypus.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-dex-orca.yaml
                        ;;
                    liquidity)
                        # TODO: Move all liquidity scraper from pod to job manifest type
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-liquidity-platypus.yaml
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-liquidity-orca.yaml
                        ;;
                    foreign)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            create -f deployments/k8s-yaml/scraper-foreign-yahoofinance.yaml
                        # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        #     create -f deployments/k8s-yaml/scraper-foreign-googlefinance.yaml
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                    esac
                    echo "Example ${paths[2]} created with success"
                else
                    echo "Creating all examples ..."
                    # Exchange
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-cex-bitfinex.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-cex-bittrex.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-cex-coinbase.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-cex-mexc.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-cex-bitmart.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-dex-platypus.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-dex-orca.yaml
                    # Liquidity
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-liquidity-platypus.yaml
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-liquidity-orca.yaml
                    # Foreign
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        create -f deployments/k8s-yaml/scraper-foreign-yahoofinance.yaml
                    # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    #     create -f deployments/k8s-yaml/scraper-foreign-googlefinance.yaml
                    echo "All examples created"
                fi
                ;;
            *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    remove)
        if [ "${#paths[@]}" -gt 1 ]; then
            case "${paths[1]}" in
            exchange)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    delete -f deployments/k8s-yaml/scraper-cex.yaml || true
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    delete -f deployments/k8s-yaml/scraper-dex.yaml || true
                ;;
            liquidity)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    delete -f deployments/k8s-yaml/scraper-liquidity.yaml || true
                ;;
            foreign)
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    delete -f deployments/k8s-yaml/scraper-foreign.yaml || true
                ;;
            cronjob)
                if [ "${#paths[@]}" -eq 2 ]; then
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f "deployments/k8s-yaml/cronjob-snapshot.yaml" || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete secret regcred || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete configmap postgres-entrypoint || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete configmap postgres-crondump || true
                else
                    echo "Unknown command" >&2
                    exit 1
                fi
                ;;
            example)
                if [ "${#paths[@]}" -gt 2 ]; then
                    echo "Removing ${paths[2]} example ..."
                    case "${paths[2]}" in
                    exchange)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-cex-bitfinex.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-cex-bittrex.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-cex-coinbase.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-cex-mexc.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-cex-bitmart.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-dex-platypus.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-dex-orca.yaml || true
                        ;;
                    liquidity)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-liquidity-platypus.yaml || true
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-liquidity-orca.yaml || true
                        ;;
                    foreign)
                        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                            delete -f deployments/k8s-yaml/scraper-foreign-yahoofinance.yaml || true
                        # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        #     delete -f deployments/k8s-yaml/scraper-foreign-googlefinance.yaml || true
                        ;;
                    *)
                        echo "Unknown command" >&2
                        exit 1
                        ;;
                    esac
                    echo "Example ${paths[2]} removed with success"
                else
                    echo "Removing all examples ..."
                    # Exchange
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-cex-bitfinex.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-cex-bittrex.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-cex-coinbase.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-cex-mexc.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-cex-bitmart.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-dex-platypus.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-dex-orca.yaml || true
                    # Liquidity
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-liquidity-platypus.yaml || true
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-liquidity-orca.yaml || true
                    # Foreign
                    minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        delete -f deployments/k8s-yaml/scraper-foreign-yahoofinance.yaml || true
                    # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    #     delete -f deployments/k8s-yaml/scraper-foreign-googlefinance.yaml || true
                    echo "All examples removed"
                fi
                ;;
            *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            echo "Unknown command" >&2
            exit 1
        fi
        ;;
    info)
        minikube addons list
        minikube profile list
        echo "PWD: $PWD"
        echo "SCRIPT_FOLDER: $SCRIPT_FOLDER"
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            echo "OSTYPE: GNU/Linux"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            echo "OSTYPE: Mac OSX"
        fi
        # TODO: uptime show the host uptime, not the minikube uptime
        #   https://stackoverflow.com/a/28353785/2042014
        uptime=$(minikube -p "${MINIKUBE_PROFILE}" ssh -- uptime -p)
        echo "Uptime: $uptime"
        echo; echo "Images:"
        minikube -p "${MINIKUBE_PROFILE}" image ls
        echo; echo "Status:"
        minikube -p "${MINIKUBE_PROFILE}" status
        echo; echo "Disk available:"
        minikube -p "${MINIKUBE_PROFILE}" ssh -- df -h
        if [[ "$MINIKUBE_DRIVER" == "docker" ]]; then
            echo; echo "Disk available of Docker:"
            minikube -p "${MINIKUBE_PROFILE}" ssh -- docker system df
        fi
        ;;
    ping)
        echo "Ping tests:"
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-redis.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-redis.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-redis >/dev/null 2>&1 \
            && echo "  Redis OK" || echo "  Redis FAILED" >&2
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-influx.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-influx.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-influx >/dev/null 2>&1 \
            && echo "  InfluxDB OK" || echo "  InfluxDB FAILED" >&2
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-postgres.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-postgres.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-postgres >/dev/null 2>&1 \
            && echo "  PostgreSQL OK" || echo "  PostgreSQL FAILED" >&2
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            delete -f deployments/k8s-yaml/job-ping-kafka.yaml >/dev/null 2>&1 || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            create -f deployments/k8s-yaml/job-ping-kafka.yaml >/dev/null 2>&1
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            wait --timeout=30s --for=condition=complete job/ping-kafka >/dev/null 2>&1 \
            && echo "  Kafka OK" || echo "  Kafka FAILED" >&2
        ;;
    code-lint)
        echo "Linting ..."
        golangci-lint run --config=./.golangci.yml --out-format=tab
        ;;
    code-test)
        echo "Testing ..."
        gotestsum --format pkgname
        ;;
    code-build)
        echo "Building ..."
        go build -v ./...
        ;;
    monitor-start) # TODO: this is not working
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create namespace dia-monitoring
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- create namespace logging

        # Install grafana dashboards
        #   TODO: provisioning datasources and dashboards
        helm repo add grafana https://grafana.github.io/helm-charts
        helm repo update
        helm upgrade --namespace=dia-monitoring --install grafana grafana/grafana 
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            expose --namespace=dia-monitoring service grafana --type=NodePort --target-port=3000 --name=grafana-np
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            get secret --namespace=dia-monitoring grafana \
            -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
        minikube -p "${MINIKUBE_PROFILE}" service grafana-np --url

        # TODO: Installing Loki daemon
        helm repo add grafana https://grafana.github.io/helm-charts
        helm repo update
        helm upgrade --namespace=logging --install loki grafana/loki
        # --values ./deployments/k8s-yaml/external-loki-values.yaml
        ;;
    monitor-stop) # TODO: this is not working
        # Stop and un-install grafana
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete svc --namespace=dia-monitoring grafana-np || true
        helm delete grafana || true
        
        # Stop and un-install Loki
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete svc --namespace=dia-monitoring loki || true
        helm delete loki || true

        # Clean Helm repos
        helm repo remove grafana || true
        helm repo update

        # Delete remaining resources
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete namespace dia-monitoring || true
        minikube -p "${MINIKUBE_PROFILE}" kubectl -- delete namespace logging || true
        ;;
    data-reset)
        if [ "${#paths[@]}" -gt 1 ]; then
            case "${paths[1]}" in
                foreign)
                    # echo "Exchange:"
                    # read -r inputExchangeName
                    echo "WIP ..."
                    # inputExchangeName="YahooFinanceA"
                    # echo "Removing InfluxDB data for $inputExchangeName exchange ..."
                    # TODO: not implemented in influxdb 1.8, DELETE does not support fields in the WHERE clause. (https://archive.docs.influxdata.com/influxdb/v1.1/query_language/database_management/#delete-series-with-delete)
                    # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    #     exec deployment/data-influx -- \
                    #     influx -host 'localhost' -port '8086' -database 'dia' -execute "DELETE FROM foreignquotation WHERE source = '$inputExchangeName'"
                    ;;
                *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            echo "Resetting InfluxDB data ..."
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' \
                -execute 'DROP MEASUREMENT foreignquotation'
            echo " foreignquotation dropped"
            minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' \
                -execute 'DROP MEASUREMENT tradesTmp'
            echo " tradesTmp dropped"
            echo "Resetting PostgreSQL data ..."
            # TODO: error handling when cannot delete row
            # minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
            #     exec deployment/data-postgres -- \
            #     psql -U postgres -t \
            #     -c "DELETE FROM exchange WHERE name = 'Custom'" >/dev/null 2>&1 \
            #     && echo "Row deleted." \
            #     || echo "Error, a exchange does not exists and cannot be deleted." >&2
        fi
        ;;
    data-list)
        # TODO: SELECT * | wc of Influx data is very slow, maybe use COUNT
        if [ "${#paths[@]}" -gt 1 ]; then
            case "${paths[1]}" in
            liquidity)
                echo "Enter the name of exchange to query:"
                echo "PostgreSQL Data:"
                echo "  Name: $inputExchangeName"
                is_centralized=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -AXqt \
                    -c "SELECT centralized FROM exchange WHERE name = '$inputExchangeName'" | sed 's/\r$//')
                echo "  Centralized: $is_centralized"
                is_bridge=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT bridge FROM exchange WHERE name = '$inputExchangeName'")
                echo "  Bridge: $is_bridge"
                is_active=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT scraper_active FROM exchange WHERE name = '$inputExchangeName'")
                echo "  Active: $is_active"
                ;;
            foreign)
                echo "Enter the name of exchange to query:"
                read -r inputExchangeName
                echo "InfluxDB Data:"
                num_foreignquotation=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-influx -- \
                    influx -host 'localhost' -port '8086' -database 'dia' \
                    -execute "SELECT * FROM foreignquotation WHERE source = '$inputExchangeName'" | wc -l)
                echo "  Num. of foreign quotations: $num_foreignquotation"
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-influx -- \
                    influx -host 'localhost' -port '8086' -database 'dia' \
                    -execute "SELECT * FROM foreignquotation WHERE source = '$inputExchangeName' ORDER BY time DESC LIMIT 10"
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-influx -- \
                    influx -host 'localhost' -port '8086' -database 'dia' \
                    -execute "SELECT * FROM foreignquotation WHERE source = '$inputExchangeName' ORDER BY time DESC LIMIT 10"
                ;;
            exchange)
                echo "Exchange:"
                read -r inputExchangeName
                minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -t \
                    -c "SELECT exchange_id FROM exchange WHERE name = '$inputExchangeName'" \
                    | if [[ $(wc -l) -ge 2 ]]; then echo "Found"; else echo "Not Found"; exit 1; fi
                echo "InfluxDB Data:"
                num_trades=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-influx -- \
                    influx -host 'localhost' -port '8086' -database 'dia' \
                    -execute "SELECT * FROM tradesTmp WHERE exchange = '$inputExchangeName'" | wc -l)
                echo "  Num. of trades: $num_trades"
                echo "PostgreSQL Data:"
                echo "  Name: $inputExchangeName"
                is_centralized=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -AXqt \
                    -c "SELECT centralized FROM exchange WHERE name = '$inputExchangeName'" | sed 's/\r$//')
                echo "  Centralized: $is_centralized"
                is_bridge=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT bridge FROM exchange WHERE name = '$inputExchangeName'")
                echo "  Bridge: $is_bridge"
                is_active=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/data-postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT scraper_active FROM exchange WHERE name = '$inputExchangeName'")
                echo "  Active: $is_active"
                if [[ "$is_centralized" == "t" ]]; then
                    num_exchangepairs=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM exchangepair WHERE exchange = '$inputExchangeName'")
                    echo "  Num. of exchange pairs: $num_exchangepairs"
                    num_exchangepairassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM asset WHERE asset_id IN (SELECT id_quotetoken FROM exchangepair WHERE exchange = '$inputExchangeName') OR asset_id IN (SELECT id_basetoken FROM exchangepair WHERE exchange = '$inputExchangeName')")
                    echo "    Num. of assets: $num_exchangepairassets"
                    num_exchangesymbols=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM exchangesymbol WHERE exchange = '$inputExchangeName'")
                    echo "  Num. of exchange symbols: $num_exchangesymbols"
                    num_exchangesymbolsassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM asset WHERE asset_id IN (SELECT asset_id FROM exchangesymbol WHERE exchange = '$inputExchangeName')")
                    echo "    Num. of assets: $num_exchangesymbolsassets"
                else
                    blockchain=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT blockchain FROM exchange WHERE name = '$inputExchangeName'")
                    echo "  Blockchain: $blockchain"
                    num_pools=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM pool WHERE exchange = '$inputExchangeName'")
                    echo "  Num. of pools: $num_pools"
                    last_liquidityupdate=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT time_stamp FROM poolasset WHERE pool_id IN (SELECT pool_id FROM pool WHERE exchange = '$inputExchangeName') ORDER BY time_stamp DESC LIMIT 1")
                    num_poolassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM poolasset WHERE pool_id IN (SELECT pool_id FROM pool WHERE exchange = '$inputExchangeName')")
                    echo "    Num. of pool assets: $num_poolassets (Last update at $last_liquidityupdate)"
                    num_poolassetsassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                        exec deployment/data-postgres -- \
                        psql -U postgres -tA \
                        -c "SELECT COUNT(*) FROM asset WHERE asset_id IN (SELECT asset_id FROM poolasset WHERE pool_id IN (SELECT pool_id FROM pool WHERE exchange = '$inputExchangeName'))")
                    echo "      Num. of assets: $num_poolassetsassets"
                fi
                ;;
            blockchain)
                echo "Blockchain:"
                read -r inputBlockchainName
                echo "PostgreSQL Data:"
                verificationmechanism=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT verificationmechanism FROM blockchain WHERE name = '$inputBlockchainName'")
                echo "  Consensus: $verificationmechanism"
                genesisdate=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT genesisdate FROM blockchain WHERE name = '$inputBlockchainName'")
                echo "  Genesis Date: $genesisdate"
                chainid=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT chain_id FROM blockchain WHERE name = '$inputBlockchainName'")
                echo "  Chain ID: $chainid"
                num_blockchainassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                    exec deployment/postgres -- \
                    psql -U postgres -tA \
                    -c "SELECT COUNT(*) FROM asset WHERE blockchain = '$inputBlockchainName'")
                echo "  Num. of blockchain assets: $num_blockchainassets"
                ;;
            *)
                echo "Unknown command" >&2
                exit 1
                ;;
            esac
        else
            echo "InfluxDB Data:"
            num_tradestmp=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' \
                -execute 'SELECT * FROM tradesTmp' | wc -l)
            echo "  Num. of tradesTmp: $num_tradestmp"
            num_filters=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' \
                -execute 'SELECT * FROM filters' | wc -l)
            echo "  Num. of filters: $num_filters"
            num_quotations=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' \
                -execute 'SELECT * FROM assetQuotations' | wc -l)
            echo "  Num. of quotations: $num_quotations"
            num_foreignquotation=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-influx -- \
                influx -host 'localhost' -port '8086' -database 'dia' \
                -execute 'SELECT * FROM foreignquotation' | wc -l)
            echo "  Num. of foreign quotations: $num_foreignquotation"
            echo "PostgreSQL Data:"
            num_exchanges=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM exchange")
            echo "  Num. of exchanges: $num_exchanges"
            num_pools=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM pool")
            echo "  Num. of pools: $num_pools"
            num_poolassets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM poolasset")
            echo "  Num. of pool assets: $num_poolassets"
            num_assets=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM asset")
            echo "  Num. of assets: $num_assets"
            num_exchangepairs=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM exchangepair")
            echo "  Num. of exchange pairs: $num_exchangepairs"
            num_exchangesymbols=$(minikube -p "${MINIKUBE_PROFILE}" kubectl -- \
                exec deployment/data-postgres -- \
                psql -U postgres -tA -c "SELECT COUNT(*) FROM exchangesymbol")
            echo "  Num. of exchange symbols: $num_exchangesymbols"
        fi
        ;;
    *)
        echo "Unknown command" >&2
        exit 1
        ;;
    esac
}

main "$@"